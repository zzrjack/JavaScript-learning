三点运算符作为剩余参数-理解为把剩余的元素集合在一起

	//这里的10 20 30 分别传到函数作为形参，形参只有a和...rest,那么...rest其实就是把剩余的20 30集合一起接收了，变为了[20,30]
	function func2(a, ...rest) { 
	    console.log(a); //10
	    console.log(rest); //[20,30]
	    console.log(rest[0], rest[1], rest[2]); //20 30 undefined
	}
	func2(10, 20, 30);
二、三点运算符作为拓展运算符-也就是把元素拆开

	let arr = [10, 20, 30];
	function func2(a, b, c) {
	    console.log(a, b, c); //10 20 30 
	}
	func2(...arr); //这个...arr相当于把数组的元素拓展出来，也就是拆了数组，变为10 20 30传给函数的a b c分别接收
	

三、三点运算符还可以做什么
（1）合并数组


	let arr1 = [10, 20];
	let arr2 = [30, 40];
	let new_arr = [...arr1, ...arr2];
	console.log(new_arr); //[ 10, 20, 30, 40 ]

（2）合并对象–如果是2个对象合并，属性有相同的，后面的会覆盖前面的


	let obj1 = {
	    name: "nodejs",
	    age: 111,
	    email: "123@qq.com"
	}
	let obj2 = {
	    name: "js",
	    age: 222,
	    email: "node@qq.com"
	}
	// 
	let new_obj = { ...obj1, ...obj2 };
	console.log(new_obj); //{ name: 'js', age: 222, email: 'node@qq.com' }
合并对象和合并数组的区别就是在于一个是{ }，一个是[ ]
四、arguements  永远不要命名参数arguments。这将优先于arguments赋予每个函数范围的对象。
arguments 是是JavaScript里的一个内置对象，它很古怪，也经常被人所忽视，但实际上是很重要的。所有主要的js函数库都利用了arguments对象。所以agruments对象对于javascript程序员来说是必需熟悉的。在javascript函数体内，标识符arguments具有特殊含义。它是调用对象的一个特殊属性，用来引用Arguments对象。Arugments对象就像数组，注意这里只是像并不是哈。

javascript函数体内，arguments像数组(并不是真的数组，是一个Arguments对象，再次强调)一样，有length属性，可以代表传给函数的参数的个数。

javascript中Arguments对象是函数的实际参数，arguments对象的长度是由实参个数而不是形参个数决定的。形参是函数内部重新开辟内存空间存储的变量，但是其与arguments对象内存空间并不重叠。

js不会主动为你判断你到底给函数传了多少个参数，如果你多传了，多余的部分就没有被使用，如果你少传了，那么没传的参数值就是undefined.所以我们可以借助arguments的length属性来检测调用函数时是否使用了正确数目的实际参数，因为javascript是不会为你做这些事的

JavaScript 中除了变量外还有常量，常量与变量本质的区别是【常量必须要有值且不允许被重新赋值】，常量值为对象时其属性和方法允许重新赋值。

作用域：
总结：
let 声明的变量会产生块作用域，var 不会产生块作用域
const 声明的常量也会产生块作用域
不同代码块之间的变量无法互相访问
推荐使用 let 或 const
注：开发中 let 和 const 经常不加区分的使用，如果担心某个值会不小被修改时，则只能使用 const 声明成常量。
// 整理：
// 作用域：变量的使用范围		
// 全局作用域：函数外部的作用域，在全局申明的变量称为全局变量，可以在任何地方使用
// 局部作用域：函数内部的作用域，在局部申明的变量称为局部变量，只能在当前作用域使用
// 块级作用域：大括号包裹的代码块，就是块级作用域
// 申明：
// let var const

作用域链本质上是底层的变量查找机制，在函数被执行时，会优先查找当前函数作用域中查找变量，如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域

嵌套关系的作用域串联起来形成了作用域链
相同作用域链中按着从小到大的规则查找变量
子作用域能够访问父作用域，父级作用域无法访问子级作用域（就近原则）


闭包
闭包是一种比较特殊和函数，使用闭包能够访问函数作用域中的变量。从代码形式上看闭包是一个做为返回值的函数
总结：
闭包本质仍是函数，只不是从函数内部返回的
闭包能够创建外部可访问的隔离作用域，避免全局变量污染，能够是变量的作用范围延伸
过度使用闭包可能造成内存泄漏
注：回调函数也能访问函数内部的局部变量。
含义：
一个作用域有权访问另外一个作用域的局部变量
从代码格式上看，就是返回一个子函数，子函数访问父函数的局部变量
作用：延长变量的使用范围
缺点：容易引起内存泄漏
代码
Function father () { let num = 132; return function () {console.log(num)} };
Let re = Faher()

预解析：代码在执行之前，先要预解析，解析变量和函数
变量：带有申明的变量
	变量解析，变量提升
	JS会把申明的变量，提升到当前作用域的最前面，只申明不赋值

函数：代有函数名的变量
	函数解析，函数提升
	JS会把带有名字的函数，提升到当前作用域最前面，只定义不调用

动态参数arguments   （伪数组）
剩余参数：写法  ...
...是语法符号置于最末函数形参之前，用于获取多余的实参
借助...获取的剩余实参

箭头函数不存在预解析
不存在arguments
箭头函数中不存在this   箭头函数中的this 指向的是上级作用域的this
函数中的this指向 调用者 


解构赋值
变量大于单元值数量时，多余的变量将被赋值为undefined
变量的数量小于单元值数量时，可以通过...获取剩余单元值，但只能置于最末位

对象解构
对象解开结构 赋值给变量
用冒号改名字
uname:userName
console.log(userName,sex )
对象找不到与变量名一致的属性时值为undefined
允许初始化变量的默认值，属性不存在或单元值为undefined时默认值才会生效
支持多维解构赋值
instanseof 用于判断一个对象是否是另一个构造函数的实例对象
constructor： 指回构造函数本身
